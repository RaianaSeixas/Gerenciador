# -*- coding: utf-8 -*-
"""WOA_jan_28_2019.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/github/ucfilho/Codigos_Teste/blob/master/WOA_jan_28_2019.ipynb
"""

"""WOA - Whale Optimization Algorithm

O vetor X eh otimizado com p aleatorio sendo corrigido em espiral ou nao (prob de 50%)

O vetor a_k decai linearmente 

A matriz A_kp vai de para zero (o que gera um espiral de aproximacao)
"""
import numpy as np

'''
FOBJ gera vetorialmente os valores com a funcao objetivo escalar
em outras palavras gera para populacao o valor da funcao a ser otimizada
'''
def FOBJ(X,Fun):
    rows = X.shape[0]
    fobj=np.zeros(rows)
    for i in range(rows):
        fobj[i]=Fun(X[i,])
    return fobj

'''Enxame retorna a populacao aleatoria com todos valores entre MIN e MAX'''
def Enxame(PAR,NPAR,MAX,MIN):
    x=np.zeros((NPAR, len(MAX)))
    for j in range(len(MAX)):
        for i in range(NPAR):
            x[i,j]=MIN[j]+(MAX[j]-MIN[j])*np.random.random()
    return x

''' 
Fit ordena os vetores do que fornece MIN a MAX valor de FOBJ : 
        eh necessario para encontrar Best baleia
'''
def FIT(X):
    fit=np.argsort(X)
    return fit

''' 
Matriz_AC 
  retorna matriz A decrescente q vai 2 a zero
  retorna matriz C
  A decrescente q vai 2 a zero
  C aleatoria q vai de 
'''
def Matriz_AC(a,PAR,NPAR):
  A=np.zeros((NPAR, PAR))
  C=np.zeros((NPAR, PAR))
  for j in range(PAR):
    for i in range(NPAR):
      A[i,j]=a*(2*np.random.random()-1)
      C[i,j]=2*np.random.random()
  return A,C

# retorna o best X*
def BEST(x,Fun):
  ycal=FOBJ(x,Fun)
  Ind=FIT(ycal) # retorna o índice em ordem crescente de FO
  Best=x[Ind[0],]
  return Best

# atualiza a matriz de populacoes
def New_X(k,ITE,PAR,NPAR,MAX,MIN,Best,X):
  a=2*(k-ITE)/(1-ITE) # parametro que varia de 2 a zero linermente: gera espiral
  A,C=Matriz_AC(a,PAR,NPAR)# matriz da espiral e matrix aletoria range dobro
  Xrand=Enxame(PAR,NPAR,MAX,MIN) #  sera utilizado para A>=1
  for j in range(PAR):
    for i in range(NPAR):
      l=np.random.random()*2 - 1 # valor entre [-1,1]
      p=np.random.random() # valor entre [0,1]
      if(p< 0.5):
        if(A[i,j]<1):
          D=abs(Best[j]*C[i,j]-X[i,j])
          X[i,j]=Best[j]-A[i,j]*D
        else: #(A[i,j]>1):
          D=abs(Xrand[i,j]*C[i,j]-X[i,j])#testar versão com baleia aleatória entre X e n gerar um novo X
          X[i,j]=Xrand[i,j]-A[i,j]*D
      else: #if(p< 0.5):
        D=abs(Best[j]-X[i,j])
        X[i,j]=D*np.exp(l*2)*np.cos(2*np.pi*l)+Best[j] #b=2 (e^bl)
        
      if(X[i,j]> MAX[j]):
        X[i,j]=MAX[j]
      if(X[i,j]< MIN[j]):
        X[i,j]=MIN[j]
        
  return X

def WOA(ITE,PAR,NPAR,MAX,MIN,Fun,x): # realiza todas interacoes do WOA
  k=1 #contador de iteracoes
#  x=Enxame(PAR,NPAR,MAX,MIN) # inicializa baleias
  Best=BEST(x,Fun)
  while(k<=ITE):
    x=New_X(k,ITE,PAR,NPAR,MAX,MIN,Best,x) # atualiza baleias
    Best=BEST(x,Fun) # atualiza melhor baleia
    k=k+1 # atualiza iteracoes
    if k==ITE-1: #Coletar X e Y ordenados da ultima iteração
        FOBEST=Fun(Best)
        y=FOBJ(x,Fun)
        XY= np.c_[x,y] #concatena x e y em 2 colunas            
        XYsorted = XY[XY[:,-1].argsort()] # Ordena os dados a partir da coluna 2 (Y) para todas as linhas
  return Best,FOBEST,XYsorted  


'''
###################### Main
import Function
#Fun=Function.Schwefel
#Fun=Function.Rosenbrock
Fun=Function.Shubert

NPAR=200 #Baleias
ITE=50 #ITERACOES
PAR=2 #NUM DE PARAMETROS A SER OTIMIZADOS
MAX=[10,10] # MAXIMO DE CADA PARAMETRO
MIN=[-10,-10] # MINIMO DE CADA PARAMETRO

X=Enxame(PAR,NPAR,MAX,MIN) # inicializa baleias
Best,FOBEST,XY=WOA(ITE,PAR,NPAR,MAX,MIN,Fun,X)
print("Baleias=",NPAR,"      Iteracoes=",ITE,"   x=",Best,"       fobj=",FOBEST,"\n")
'''
