# -*- coding: utf-8 -*-
"""ABCOptim_jun_10_2019.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1KxLGSILwQZQySSynZeoDYtyG4TLz_IRh
"""

import numpy as np
from random import randint
import Function
#import Enxame

''' 
FOBJ gera vetorialmente os valores com a funcao objetivo escalar
em outras palavras gera para populacao o valor da funcao 
a ser otimizada
'''
def FOBJ(X,Fun):
    rows = X.shape[0]
    fobj=np.zeros(rows)
    for i in range(rows):
        fobj[i]=Fun(X[i,])
    return fobj

'''Enxame retorna a populacao aleatoria com todos valores entre MIN e MAX'''
def Enxame(PAR,NPAR,MAX,MIN):
    x=np.zeros((NPAR, len(MAX)))
    for j in range(len(MAX)):
        for i in range(NPAR):
            x[i,j]=MIN[j]+(MAX[j]-MIN[j])*np.random.random()
    return x

''' 
Fitness gera vetorialmente os valores com a funcao fitness
equivale a quantidade de nectar da fonte
'''
def FIT(X,Fun):
    rows = X.shape[0]
    fit=np.zeros(rows)
    fit=np.copy(FOBJ(X,Fun))
    for i in range(rows):
        if(fit[i]>=0):
            fit[i]=1/(fit[i]+1)
        else:
            fit[i]=1+abs(fit[i])
    return fit

'''
probablilidade usada para roleta q atualizacao das onlookers 
semelhante ao genetico
'''

def PROB(x,Fun):
    rows=x.shape[0]
    fit=np.zeros(rows)
    prob=np.zeros(rows)
    fit=FIT(x,Fun)
    fit_ref=max(fit)
    
    for i in range(rows):
        prob[i] = 0.9*fit[i]/fit_ref+0.1

    return prob

'''
Obtem a melhor escolha greedy search
'''
def GetBest(x,xbest,Fun):
    ycal=FOBJ(x,Fun)
    best=np.argmin(ycal)
    yref=Fun(xbest)
    if(yref<ycal[best]):
        GBEST=xbest
    else:
        GBEST=x[best,]
    return GBEST

'''
employed bee phase
'''
def EmployedBee(xo,x,MAX,MIN,trial,Fun) :
    NPAR = xo.shape[0]
    PAR= xo.shape[1]
    V=np.zeros((NPAR, len(MAX)))

    for j in range(PAR):
        for i in range(NPAR):
            fi=np.random.uniform(low=-1.0, high=1.0, size=None)
            rd=randint(0, (NPAR-1))
            V[i,j]=xo[i,j]+(xo[i,j] -x[rd,j])*fi # candidata a solucao
            if (V[i,j]>MAX[j]):
              V[i,j]=np.copy(MAX[j]) # restringe a busca para o intervalo
            if (V[i,j]<MIN[j]):
              V[i,j]=np.copy(MIN[j]) # restringe a busca para o intervalo
              
    YCAL=FOBJ(xo,Fun)
    YV=FOBJ(V,Fun)
    for i in range(NPAR):
        if(YV[i]<YCAL[i]):
          trial[i]=0
          x[i,]=np.copy(V[i,])
        else:
          trial[i]=trial[i]+1
            

    return x,trial

'''
onlooker bee phase
'''
def OnlookerBee(xo,x,trial,MAX,MIN,Fun): #OnlookerBee(xo,x_Employed)
    rows = xo.shape[0]
    cols = xo.shape[1]
    prob=PROB(x,Fun)
    prob_ref=max(prob)
    #best=np.argmax(prob)
    
    for i in range(rows):
      prob_ref=np.random.uniform(low=0, high=1.0, size=None)
      rd=randint(0, (rows-1))
      if(prob[i] > prob_ref):  
        fi=np.random.uniform(low=-1.0, high=1.0, size=None)
        Xmi=xo[i,]+fi*(xo[i,]-x[rd,])
        xo[i,]=np.copy(Xmi)
        for j in range(cols):
          if (xo[i,j]>MAX[j]):
            xo[i,j]=np.copy(MAX[j]) # restringe a busca para o intervalo
          if (xo[i,j]<MIN[j]):
            xo[i,j]=np.copy(MIN[j]) # restringe a busca para o intervalo
    
    YCAL=FOBJ(x,Fun)
    YV=FOBJ(xo,Fun)
        
    for i in range(rows):
      if(YV[i]<YCAL[i]):
        trial[i]=0
        x[i,]=np.copy(xo[i,])
      else:
        trial[i]=trial[i]+1
    return xo,trial

'''
scout bee phase
'''
def ScoutBee(trial,x,ntrail,MAX,MIN):
#def ScoutBee(x,trial,MAX,MIN):
    PAR = x.shape[0]
    NPAR = x.shape[1]
    for i in range(PAR):
      if(trial[i]>= ntrail):
        trial[i]=0
        for j in range(NPAR):
          x[i,j]=MIN[j]+(MAX[j]-MIN[j])*np.random.random()
    return x,trial

'''
Metodo que alterna e coordena o uso employers,onlooker, scout bees
e greedy search

'''
def ABCOPtim(ITE,PAR,ntrail,NPAR,MAX,MIN,Fun):

    trial=np.zeros(NPAR) # inicializa contador p abandonar fonte de alimento
    xbest=Enxame(PAR,1,MAX,MIN)[0,] #inicializa xbest
    xo=Enxame(PAR,NPAR,MAX,MIN) # inicializa employed bee
    xbest=GetBest(xo,xbest,Fun)
    
    for i in range(ITE):
      x=Enxame(PAR,NPAR,MAX,MIN) # comparativo para employed bee
      xo,trial=EmployedBee(xo,x,MAX,MIN,trial,Fun)
      xbest=GetBest(x,xbest,Fun)
      x=Enxame(PAR,NPAR,MAX,MIN)  # comparativo para OnlookerBee
      xo,trial=OnlookerBee(xo,x,trial,MAX,MIN,Fun)
      xbest=GetBest(xo,xbest,Fun)
      #xbest=GetBest(xo,xbest)
      x=Enxame(PAR,NPAR,MAX,MIN) # comparativo para ScoutBee
      xo,trial=ScoutBee(trial,x,ntrail,MAX,MIN) #  ScoutBee ( a rigor so esta linha basta)
      xbest=GetBest(xo,xbest,Fun)
      x=np.copy(xo)
    
    return xbest, x,trial

#'''
    
dim=3
Fun=Function.Schwefel
MAX=np.repeat(500,dim)
MIN=np.repeat(-500,dim)

NPAR=200 #PARTICULAS (fontes de comida)
ITE=100 #ITERACOES
PAR=len(MAX)
ntrail=10 #numero de buscas ate abandonar uma fonte de alimento

for i in range(1):
    print("resolucao",i+1," ")
    xbest, x,trial =ABCOPtim(ITE,PAR,ntrail,NPAR,MAX,MIN,Fun)
    print("vetor",xbest,"funcao", Fun(xbest),"\n")

#print(trial)
#'''